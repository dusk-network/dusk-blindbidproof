<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `cptrx2` type in crate `packed_simd`."><meta name="keywords" content="rust, rustlang, rust-lang, cptrx2"><title>packed_simd::cptrx2 - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc type"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../packed_simd/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Type Definition cptrx2</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.add">add</a><a href="#method.eq">eq</a><a href="#method.extract">extract</a><a href="#method.extract_unchecked">extract_unchecked</a><a href="#method.from_slice_aligned">from_slice_aligned</a><a href="#method.from_slice_aligned_unchecked">from_slice_aligned_unchecked</a><a href="#method.from_slice_unaligned">from_slice_unaligned</a><a href="#method.from_slice_unaligned_unchecked">from_slice_unaligned_unchecked</a><a href="#method.ge">ge</a><a href="#method.gt">gt</a><a href="#method.is_null">is_null</a><a href="#method.lanes">lanes</a><a href="#method.le">le</a><a href="#method.lt">lt</a><a href="#method.ne">ne</a><a href="#method.new">new</a><a href="#method.null">null</a><a href="#method.offset">offset</a><a href="#method.offset_from">offset_from</a><a href="#method.read">read</a><a href="#method.replace">replace</a><a href="#method.replace_unchecked">replace_unchecked</a><a href="#method.shuffle1_dyn">shuffle1_dyn</a><a href="#method.splat">splat</a><a href="#method.sub">sub</a><a href="#method.wrapping_add">wrapping_add</a><a href="#method.wrapping_offset">wrapping_offset</a><a href="#method.wrapping_offset_from">wrapping_offset_from</a><a href="#method.wrapping_sub">wrapping_sub</a><a href="#method.write_to_slice_aligned">write_to_slice_aligned</a><a href="#method.write_to_slice_aligned_unchecked">write_to_slice_aligned_unchecked</a><a href="#method.write_to_slice_unaligned">write_to_slice_unaligned</a><a href="#method.write_to_slice_unaligned_unchecked">write_to_slice_unaligned_unchecked</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Eq">Eq</a><a href="#impl-From%3C%5B*const%20T%3B%202%5D%3E">From&lt;[*const T; 2]&gt;</a><a href="#impl-Hash">Hash</a><a href="#impl-Into%3C%5B*const%20T%3B%202%5D%3E">Into&lt;[*const T; 2]&gt;</a><a href="#impl-PartialEq%3CSimd%3C%5B*const%20T%3B%202%5D%3E%3E">PartialEq&lt;Simd&lt;[*const T; 2]&gt;&gt;</a></div></div><p class='location'><a href='index.html'>packed_simd</a></p><script>window.sidebarCurrent = {name: 'cptrx2', ty: 'type', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#10' title='goto source code'>[src]</a></span><span class='in-band'>Type Definition <a href='index.html'>packed_simd</a>::<wbr><a class="type" href=''>cptrx2</a></span></h1><pre class='rust typedef'>type cptrx2&lt;T&gt; = <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[*const T; 2]&gt;;</pre><div class='docblock'><p>A vector with 2 <code>*const T</code> lanes</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#18-117' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.new' class="method"><code id='new.v'>pub const fn <a href='#method.new' class='fnname'>new</a>(x0: *const T, x1: *const T) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#24-26' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a new instance with each vector elements initialized
with the provided values.</p>
</div><h4 id='method.lanes' class="method"><code id='lanes.v'>pub const fn <a href='#method.lanes' class='fnname'>lanes</a>() -&gt; usize</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#30-32' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the number of vector lanes.</p>
</div><h4 id='method.splat' class="method"><code id='splat.v'>pub const fn <a href='#method.splat' class='fnname'>splat</a>(value: *const T) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#37-43' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new instance with each element initialized to
<code>value</code>.</p>
</div><h4 id='method.null' class="method"><code id='null.v'>pub const fn <a href='#method.null' class='fnname'>null</a>() -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#48-50' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new instance with each element initialized to
<code>null</code>.</p>
</div><h4 id='method.is_null' class="method"><code id='is_null.v'>pub fn <a href='#method.is_null' class='fnname'>is_null</a>(self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#55-57' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a mask that selects those lanes that contain <code>null</code>
pointers.</p>
</div><h4 id='method.extract' class="method"><code id='extract.v'>pub fn <a href='#method.extract' class='fnname'>extract</a>(self, index: usize) -&gt; *const T</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#65-68' title='goto source code'>[src]</a></h4><div class='docblock'><p>Extracts the value at <code>index</code>.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>If <code>index &gt;= Self::lanes()</code>.</p>
</div><h4 id='method.extract_unchecked' class="method"><code id='extract_unchecked.v'>pub unsafe fn <a href='#method.extract_unchecked' class='fnname'>extract_unchecked</a>(self, index: usize) -&gt; *const T</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#76-79' title='goto source code'>[src]</a></h4><div class='docblock'><p>Extracts the value at <code>index</code>.</p>
<h1 id="precondition" class="section-header"><a href="#precondition">Precondition</a></h1>
<p>If <code>index &gt;= Self::lanes()</code> the behavior is undefined.</p>
</div><h4 id='method.replace' class="method"><code id='replace.v'><span class="docblock attributes">#[must_use = "replace does not modify the original value - it returns a new vector with the value at `index` replaced by `new_value`d"]
</span>pub fn <a href='#method.replace' class='fnname'>replace</a>(self, index: usize, new_value: *const T) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#94-97' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a new vector where the value at <code>index</code> is replaced by
<code>new_value</code>.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>If <code>index &gt;= Self::lanes()</code>.</p>
</div><h4 id='method.replace_unchecked' class="method"><code id='replace_unchecked.v'><span class="docblock attributes">#[must_use = "replace_unchecked does not modify the original value - it returns a new vector with the value at `index` replaced by `new_value`d"]
</span>pub unsafe fn <a href='#method.replace_unchecked' class='fnname'>replace_unchecked</a>(self, index: usize, new_value: *const T) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#109-116' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a new vector where the value at <code>index</code> is replaced by <code>new_value</code>.</p>
<h1 id="precondition-1" class="section-header"><a href="#precondition-1">Precondition</a></h1>
<p>If <code>index &gt;= Self::lanes()</code> the behavior is undefined.</p>
</div></div><h3 id='impl-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-1' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#299-365' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq' class="method"><code id='eq.v'>pub fn <a href='#method.eq' class='fnname'>eq</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#302-309' title='goto source code'>[src]</a></h4><div class='docblock'><p>Lane-wise equality comparison.</p>
</div><h4 id='method.ne' class="method"><code id='ne.v'>pub fn <a href='#method.ne' class='fnname'>ne</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#313-320' title='goto source code'>[src]</a></h4><div class='docblock'><p>Lane-wise inequality comparison.</p>
</div><h4 id='method.lt' class="method"><code id='lt.v'>pub fn <a href='#method.lt' class='fnname'>lt</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#324-331' title='goto source code'>[src]</a></h4><div class='docblock'><p>Lane-wise less-than comparison.</p>
</div><h4 id='method.le' class="method"><code id='le.v'>pub fn <a href='#method.le' class='fnname'>le</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#335-342' title='goto source code'>[src]</a></h4><div class='docblock'><p>Lane-wise less-than-or-equals comparison.</p>
</div><h4 id='method.gt' class="method"><code id='gt.v'>pub fn <a href='#method.gt' class='fnname'>gt</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#346-353' title='goto source code'>[src]</a></h4><div class='docblock'><p>Lane-wise greater-than comparison.</p>
</div><h4 id='method.ge' class="method"><code id='ge.v'>pub fn <a href='#method.ge' class='fnname'>ge</a>(self, other: Self) -&gt; <a class="type" href="../packed_simd/type.msizex2.html" title="type packed_simd::msizex2">msizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#357-364' title='goto source code'>[src]</a></h4><div class='docblock'><p>Lane-wise greater-than-or-equals comparison.</p>
</div></div><h3 id='impl-2' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-2' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#582-650' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from_slice_aligned' class="method"><code id='from_slice_aligned.v'>pub fn <a href='#method.from_slice_aligned' class='fnname'>from_slice_aligned</a>(slice: &amp;[*const T]) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#590-600' title='goto source code'>[src]</a></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not aligned
to an <code>align_of::&lt;Self&gt;()</code> boundary.</p>
</div><h4 id='method.from_slice_unaligned' class="method"><code id='from_slice_unaligned.v'>pub fn <a href='#method.from_slice_unaligned' class='fnname'>from_slice_unaligned</a>(slice: &amp;[*const T]) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#608-613' title='goto source code'>[src]</a></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code>.</p>
</div><h4 id='method.from_slice_aligned_unchecked' class="method"><code id='from_slice_aligned_unchecked.v'>pub unsafe fn <a href='#method.from_slice_aligned_unchecked' class='fnname'>from_slice_aligned_unchecked</a>(slice: &amp;[*const T]) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#622-627' title='goto source code'>[src]</a></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="precondition-2" class="section-header"><a href="#precondition-2">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not aligned
to an <code>align_of::&lt;Self&gt;()</code> boundary, the behavior is undefined.</p>
</div><h4 id='method.from_slice_unaligned_unchecked' class="method"><code id='from_slice_unaligned_unchecked.v'>pub unsafe fn <a href='#method.from_slice_unaligned_unchecked' class='fnname'>from_slice_unaligned_unchecked</a>(slice: &amp;[*const T]) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#635-649' title='goto source code'>[src]</a></h4><div class='docblock'><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h1 id="precondition-3" class="section-header"><a href="#precondition-3">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> the behavior is undefined.</p>
</div></div><h3 id='impl-3' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-3' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#798-867' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.write_to_slice_aligned' class="method"><code id='write_to_slice_aligned.v'>pub fn <a href='#method.write_to_slice_aligned' class='fnname'>write_to_slice_aligned</a>(self, slice: &amp;mut [*const T])</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#806-817' title='goto source code'>[src]</a></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not
aligned to an <code>align_of::&lt;Self&gt;()</code> boundary.</p>
</div><h4 id='method.write_to_slice_unaligned' class="method"><code id='write_to_slice_unaligned.v'>pub fn <a href='#method.write_to_slice_unaligned' class='fnname'>write_to_slice_unaligned</a>(self, slice: &amp;mut [*const T])</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#825-830' title='goto source code'>[src]</a></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code>.</p>
</div><h4 id='method.write_to_slice_aligned_unchecked' class="method"><code id='write_to_slice_aligned_unchecked.v'>pub unsafe fn <a href='#method.write_to_slice_aligned_unchecked' class='fnname'>write_to_slice_aligned_unchecked</a>(self, slice: &amp;mut [*const T])</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#840-847' title='goto source code'>[src]</a></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="precondition-4" class="section-header"><a href="#precondition-4">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not
aligned to an <code>align_of::&lt;Self&gt;()</code> boundary, the behavior is
undefined.</p>
</div><h4 id='method.write_to_slice_unaligned_unchecked' class="method"><code id='write_to_slice_unaligned_unchecked.v'>pub unsafe fn <a href='#method.write_to_slice_unaligned_unchecked' class='fnname'>write_to_slice_unaligned_unchecked</a>(self, slice: &amp;mut [*const T])</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#855-866' title='goto source code'>[src]</a></h4><div class='docblock'><p>Writes the values of the vector to the <code>slice</code>.</p>
<h1 id="precondition-5" class="section-header"><a href="#precondition-5">Precondition</a></h1>
<p>If <code>slice.len() &lt; Self::lanes()</code> the behavior is undefined.</p>
</div></div><h3 id='impl-4' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-4' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1053-1319' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.offset' class="method"><code id='offset.v'>pub unsafe fn <a href='#method.offset' class='fnname'>offset</a>(self, count: <a class="type" href="../packed_simd/type.isizex2.html" title="type packed_simd::isizex2">isizex2</a>) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1092-1095' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer.</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of <code>3</code> represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot;
the address space. That is, the infinite-precision sum, in bytes
must fit in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>vec.as_ptr().offset(vec.len() as isize)</code>
is always safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension.
As such, memory acquired directly from allocators or memory
mapped files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.wrapping_offset' class="method"><code id='wrapping_offset.v'>pub fn <a href='#method.wrapping_offset' class='fnname'>wrapping_offset</a>(self, count: <a class="type" href="../packed_simd/type.isizex2.html" title="type packed_simd::isizex2">isizex2</a>) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1110-1118' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of <code>3</code> represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires unsafe).</p>
<p>Always use <code>.offset(count)</code> instead when possible, because
offset allows the compiler to optimize better.</p>
</div><h4 id='method.offset_from' class="method"><code id='offset_from.v'>pub unsafe fn <a href='#method.offset_from' class='fnname'>offset_from</a>(self, origin: Self) -&gt; <a class="type" href="../packed_simd/type.isizex2.html" title="type packed_simd::isizex2">isizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1163-1166' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the distance between two pointers.</p>
<p>The returned value is in units of <code>T</code>: the distance in bytes is
divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>This function is the inverse of offset.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and other pointer must be either in bounds
or one byte past the end of the same allocated object.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, cannot overflow
an <code>isize</code>.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact
multiple of the size of <code>T</code>.</p>
</li>
<li>
<p>The distance being in bounds cannot rely on &quot;wrapping around&quot;
the address space.</p>
</li>
</ul>
<p>The compiler and standard library generally try to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>ptr_into_vec.offset_from(vec.as_ptr())</code>
is always safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension.
As such, memory acquired directly from allocators or memory
mapped files may be too large to handle with this function.</p>
<p>Consider using wrapping_offset_from instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.wrapping_offset_from' class="method"><code id='wrapping_offset_from.v'>pub fn <a href='#method.wrapping_offset_from' class='fnname'>wrapping_offset_from</a>(self, origin: Self) -&gt; <a class="type" href="../packed_simd/type.isizex2.html" title="type packed_simd::isizex2">isizex2</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1182-1187' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the distance between two pointers.</p>
<p>The returned value is in units of <code>T</code>: the distance in bytes is
divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>If the address different between the two pointers is not a
multiple of <code>mem::size_of::&lt;T&gt;()</code> then the result of the
division is rounded towards zero.</p>
<p>Though this method is safe for any two pointers, note that its
result will be mostly useless if the two pointers aren't into
the same allocated object, for example if they point to two
different local variables.</p>
</div><h4 id='method.add' class="method"><code id='add.v'>pub unsafe fn <a href='#method.add' class='fnname'>add</a>(self, count: <a class="type" href="../packed_simd/type.usizex2.html" title="type packed_simd::usizex2">usizex2</a>) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1230-1232' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for
<code>.offset(count as isize)</code>).</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot;
the address space. That is, the infinite-precision sum must fit
in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>vec.as_ptr().add(vec.len())</code> is always
safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension.
As such, memory acquired directly from allocators or memory
mapped files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.sub' class="method"><code id='sub.v'>pub unsafe fn <a href='#method.sub' class='fnname'>sub</a>(self, count: <a class="type" href="../packed_simd/type.usizex2.html" title="type packed_simd::usizex2">usizex2</a>) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1276-1280' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot;
the address space. That is, the infinite-precision sum must fit
in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 2<sup>63</sup> bytes due to page-table
limitations or splitting the address space. However, some 32-bit
and 16-bit platforms may successfully serve a request for more
than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or
memory mapped files <em>may</em> be too large to handle with this
function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div><h4 id='method.wrapping_add' class="method"><code id='wrapping_add.v'>pub fn <a href='#method.wrapping_add' class='fnname'>wrapping_add</a>(self, count: <a class="type" href="../packed_simd/type.usizex2.html" title="type packed_simd::usizex2">usizex2</a>) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1296-1298' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>Always use <code>.add(count)</code> instead when possible, because <code>add</code>
allows the compiler to optimize better.</p>
</div><h4 id='method.wrapping_sub' class="method"><code id='wrapping_sub.v'>pub fn <a href='#method.wrapping_sub' class='fnname'>wrapping_sub</a>(self, count: <a class="type" href="../packed_simd/type.usizex2.html" title="type packed_simd::usizex2">usizex2</a>) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1315-1318' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_sub())</code>)</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>Always use <code>.sub(count)</code> instead when possible, because <code>sub</code>
allows the compiler to optimize better.</p>
</div></div><h3 id='impl-5' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-5' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1321-1330' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.shuffle1_dyn' class="method"><code id='shuffle1_dyn.v'>pub fn <a href='#method.shuffle1_dyn' class='fnname'>shuffle1_dyn</a>&lt;I&gt;(self, indices: I) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: Shuffle1Dyn&lt;Indices = I&gt;,&nbsp;</span></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1324-1329' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shuffle vector elements according to <code>indices</code>.</p>
</div></div><h3 id='impl-6' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;[T; 2]: SimdArray,&nbsp;</span></code><a href='#impl-6' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/ptr/gather_scatter.rs.html#6-35' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.read' class="method"><code id='read.v'>pub unsafe fn <a href='#method.read' class='fnname'>read</a>&lt;M&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mask: <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[M; 2]&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;value: <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[T; 2]&gt;<br>) -&gt; <a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[T; 2]&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: Mask,<br>&nbsp;&nbsp;&nbsp;&nbsp;[M; 2]: SimdArray,&nbsp;</span></code><a class='srclink' href='../src/packed_simd/api/ptr/gather_scatter.rs.html#24-34' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reads selected vector elements from memory.</p>
<p>Instantiates a new vector by reading the values from <code>self</code> for
those lanes whose <code>mask</code> is <code>true</code>, and using the elements of
<code>value</code> otherwise.</p>
<p>No memory is accessed for those lanes of <code>self</code> whose <code>mask</code> is
<code>false</code>.</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p>This method is unsafe because it dereferences raw pointers. The
pointers must be aligned to <code>mem::align_of::&lt;T&gt;()</code>.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-From%3C%5B*const%20T%3B%202%5D%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[*const T; 2]&gt; for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-From%3C%5B*const%20T%3B%202%5D%3E' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#509-523' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(array: [*const T; 2]) -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#511-522' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-PartialEq%3CSimd%3C%5B*const%20T%3B%202%5D%3E%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../packed_simd/struct.Simd.html" title="struct packed_simd::Simd">Simd</a>&lt;[*const T; 2]&gt;&gt; for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-PartialEq%3CSimd%3C%5B*const%20T%3B%202%5D%3E%3E' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#428-437' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq-1' class="method hidden"><code id='eq.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;Self) -&gt; bool</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#430-432' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-1' class="method hidden"><code id='ne.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Self) -&gt; bool</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#434-436' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-Eq' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-Eq' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#490' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Hash' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-Hash' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1004-1010' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.hash' class="method hidden"><code id='hash.v'>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: &amp;mut H)</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#1006-1009' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice' class="method hidden"><code id='hash_slice.v'>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#192-198' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#212-231' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#215-230' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Into%3C%5B*const%20T%3B%202%5D%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;[*const T; 2]&gt; for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-Into%3C%5B*const%20T%3B%202%5D%3E' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#524-538' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; [*const T; 2]</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#526-537' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Default' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="type" href="../packed_simd/type.cptrx2.html" title="type packed_simd::cptrx2">cptrx2</a>&lt;T&gt;</code><a href='#impl-Default' class='anchor'></a><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#272-278' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.default' class="method hidden"><code id='default.v'>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; Self</code><a class='srclink' href='../src/packed_simd/api/minimal/ptr.rs.html#274-277' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "packed_simd";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>