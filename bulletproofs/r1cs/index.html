<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `r1cs` mod in crate `bulletproofs`."><meta name="keywords" content="rust, rustlang, rust-lang, r1cs"><title>bulletproofs::r1cs - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bulletproofs/index.html'><div class='logo-container'><img src='https://doc.dalek.rs/assets/dalek-logo-clear.png' alt='logo'></div></a><p class='location'>Module r1cs</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'><a href='../index.html'>bulletproofs</a></p><script>window.sidebarCurrent = {name: 'r1cs', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/bulletproofs/r1cs/mod.rs.html#1-20' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>bulletproofs</a>::<wbr><a class="mod" href=''>r1cs</a></span></h1><div class='docblock'><p>The rank-1 constraint system API for programmatically defining constraint systems.</p>
<h2 id="building-a-proof-of-shuffle-constraint-system" class="section-header"><a href="#building-a-proof-of-shuffle-constraint-system">Building a proof-of-shuffle constraint system</a></h2>
<p>A shuffle is a permutation of a list of \(k\) scalars \(x_i\) into a list of \(k\) scalars \(y_i\).</p>
<p>Algebraically it can be expressed as a statement that for a free variable \(z\), the roots of the two polynomials in terms of \(z\) are the same up to a permutation:</p>
<p>\[
\prod_i (x_i - z) = \prod_i (y_i - z)
\]</p>
<p>The prover can commit to blinded scalars \(x_i\) and \(y_i\) then receive a random challenge \(z\),
and build a proof that the above relation holds.</p>
<p>K-shuffle requires \( 2*(K-1) \) multipliers.</p>
<p>For <code>K &gt; 1</code>:</p>
<pre><code class="language-ascii,no_run">

        (x_0 - z)---⊗------⊗---(y_0 - z)        // mulx[0], muly[0]
                    |      |
        (x_1 - z)---⊗      ⊗---(y_1 - z)        // mulx[1], muly[1]
                    |      |
                   ...    ...
                    |      |
    (x_{k-2} - z)---⊗      ⊗---(y_{k-2} - z)    // mulx[k-2], muly[k-2]
                   /        \
    (x_{k-1} - z)_/          \_(y_{k-1} - z)
</code></pre>
<p>Connect the left and right sides of the shuffle statement:</p>
<pre><code class="language-ascii,no_run">    mulx_out[0] = muly_out[0]
</code></pre>
<p>For <code>i == [0, k-3]</code>:</p>
<pre><code class="language-ascii,no_run">    mulx_left[i]  = x_i - z
    mulx_right[i] = mulx_out[i+1]
    muly_left[i]  = y_i - z
    muly_right[i] = muly_out[i+1]
</code></pre>
<p>The last multipliers connect the two last variables (on each side)</p>
<pre><code class="language-ascii,no_run">    mulx_left[k-2]  = x_{k-2} - z
    mulx_right[k-2] = x_{k-1} - z
    muly_left[k-2]  = y_{k-2} - z
    muly_right[k-2] = y_{k-1} - z
</code></pre>
<p>For <code>K = 1</code>:
Connect <code>x_0</code> to <code>y_0</code> directly. Since there is only one permuatation of a 1-element list, we can omit the challenge entirely as it cancels out.</p>
<pre><code class="language-ascii,no_run">    x_0 = y_0
</code></pre>
<p>Code for creating constraints for a proof-of-shuffle constraint system:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">bulletproofs</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">curve25519_dalek</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">merlin</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">rand</span>;

<span class="kw">use</span> <span class="ident">bulletproofs</span>::<span class="ident">r1cs</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">bulletproofs</span>::{<span class="ident">BulletproofGens</span>, <span class="ident">PedersenGens</span>};
<span class="kw">use</span> <span class="ident">curve25519_dalek</span>::<span class="ident">ristretto</span>::<span class="ident">CompressedRistretto</span>;
<span class="kw">use</span> <span class="ident">curve25519_dalek</span>::<span class="ident">scalar</span>::<span class="ident">Scalar</span>;
<span class="kw">use</span> <span class="ident">merlin</span>::<span class="ident">Transcript</span>;
<span class="kw">use</span> <span class="ident">rand</span>::<span class="ident">thread_rng</span>;

<span class="comment">// Shuffle gadget (documented in markdown file)</span>

<span class="doccomment">/// A proof-of-shuffle.</span>
<span class="kw">struct</span> <span class="ident">ShuffleProof</span>(<span class="ident">R1CSProof</span>);

<span class="kw">impl</span> <span class="ident">ShuffleProof</span> {
    <span class="kw">fn</span> <span class="ident">gadget</span><span class="op">&lt;</span><span class="ident">CS</span>: <span class="ident">RandomizableConstraintSystem</span><span class="op">&gt;</span>(<span class="ident">cs</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">CS</span>, <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Variable</span><span class="op">&gt;</span>, <span class="ident">y</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Variable</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(),<span class="ident">R1CSError</span><span class="op">&gt;</span> {

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">len</span>(), <span class="ident">y</span>.<span class="ident">len</span>());
        <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">len</span>();

        <span class="kw">if</span> <span class="ident">k</span> <span class="op">=</span><span class="op">=</span> <span class="number">1</span> {
            <span class="ident">cs</span>.<span class="ident">constrain</span>(<span class="ident">y</span>[<span class="number">0</span>] <span class="op">-</span> <span class="ident">x</span>[<span class="number">0</span>]);
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
        }

        <span class="ident">cs</span>.<span class="ident">specify_randomized_constraints</span>(<span class="kw">move</span> <span class="op">|</span><span class="ident">cs</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="ident">cs</span>.<span class="ident">challenge_scalar</span>(<span class="string">b&quot;shuffle challenge&quot;</span>);

            <span class="comment">// Make last x multiplier for i = k-1 and k-2</span>
            <span class="kw">let</span> (<span class="kw">_</span>, <span class="kw">_</span>, <span class="ident">last_mulx_out</span>) <span class="op">=</span> <span class="ident">cs</span>.<span class="ident">multiply</span>(<span class="ident">x</span>[<span class="ident">k</span> <span class="op">-</span> <span class="number">1</span>] <span class="op">-</span> <span class="ident">z</span>, <span class="ident">x</span>[<span class="ident">k</span> <span class="op">-</span> <span class="number">2</span>] <span class="op">-</span> <span class="ident">z</span>);

            <span class="comment">// Make multipliers for x from i == [0, k-3]</span>
            <span class="kw">let</span> <span class="ident">first_mulx_out</span> <span class="op">=</span> (<span class="number">0</span>..<span class="ident">k</span> <span class="op">-</span> <span class="number">2</span>).<span class="ident">rev</span>().<span class="ident">fold</span>(<span class="ident">last_mulx_out</span>, <span class="op">|</span><span class="ident">prev_out</span>, <span class="ident">i</span><span class="op">|</span> {
                <span class="kw">let</span> (<span class="kw">_</span>, <span class="kw">_</span>, <span class="ident">o</span>) <span class="op">=</span> <span class="ident">cs</span>.<span class="ident">multiply</span>(<span class="ident">prev_out</span>.<span class="ident">into</span>(), <span class="ident">x</span>[<span class="ident">i</span>] <span class="op">-</span> <span class="ident">z</span>);
                <span class="ident">o</span>
            });

            <span class="comment">// Make last y multiplier for i = k-1 and k-2</span>
            <span class="kw">let</span> (<span class="kw">_</span>, <span class="kw">_</span>, <span class="ident">last_muly_out</span>) <span class="op">=</span> <span class="ident">cs</span>.<span class="ident">multiply</span>(<span class="ident">y</span>[<span class="ident">k</span> <span class="op">-</span> <span class="number">1</span>] <span class="op">-</span> <span class="ident">z</span>, <span class="ident">y</span>[<span class="ident">k</span> <span class="op">-</span> <span class="number">2</span>] <span class="op">-</span> <span class="ident">z</span>);

            <span class="comment">// Make multipliers for y from i == [0, k-3]</span>
            <span class="kw">let</span> <span class="ident">first_muly_out</span> <span class="op">=</span> (<span class="number">0</span>..<span class="ident">k</span> <span class="op">-</span> <span class="number">2</span>).<span class="ident">rev</span>().<span class="ident">fold</span>(<span class="ident">last_muly_out</span>, <span class="op">|</span><span class="ident">prev_out</span>, <span class="ident">i</span><span class="op">|</span> {
                <span class="kw">let</span> (<span class="kw">_</span>, <span class="kw">_</span>, <span class="ident">o</span>) <span class="op">=</span> <span class="ident">cs</span>.<span class="ident">multiply</span>(<span class="ident">prev_out</span>.<span class="ident">into</span>(), <span class="ident">y</span>[<span class="ident">i</span>] <span class="op">-</span> <span class="ident">z</span>);
                <span class="ident">o</span>
            });

            <span class="comment">// Constrain last x mul output and last y mul output to be equal</span>
            <span class="ident">cs</span>.<span class="ident">constrain</span>(<span class="ident">first_mulx_out</span> <span class="op">-</span> <span class="ident">first_muly_out</span>);

            <span class="prelude-val">Ok</span>(())
        })
    }
}</pre></div>
<p>In this example, <code>ShuffleProof::gadget()</code> is private function that adds constraints to the constraint system that enforce that \(y\) (the outputs) are a valid reordering of \(x\) (the inputs). </p>
<p>First, the function gets a challenge scalar \(z\) by calling the <code>ConstraintSystem::challenge_scalar</code>. This challenge is generated from commitments to high-level variables that were passed to the <code>ConstraintSystem</code> when it was created. As noted in the <code>challenge_scalar</code> documentation, making sure that the challenge circuit is sound requires analysis. In this example, the challenge circuit is sound because the challenge is bound to all of the shuffle inputs and outputs, since the inputs and outputs are high-level variables.</p>
<p>After a check for the lengths of \(x\) and \(y\), the function then makes
multipliers to create polynomials in terms of the challenge scalar \(z\).
It starts with the last multipliers, representing <code>(x_{k-1} - z) * (x_{k-2} - z)</code> and <code>(y_{k-1} - z) * (y_{k-2} - z)</code>. The outputs
to these last multipliers than become an input to the next multiplier.
This continues recursively until it reaches <code>x_0</code> and <code>y_0</code>.
Then, it adds a constraint that <code>mulx_out[0]</code> = <code>muly_out[0]</code>,
which constrains that the two polynomials in terms of challenge scalar
\(z\) are equal to each other. This is true if and only if \(y\) is a valid
reordering of \(x\).</p>
<h2 id="constructing-a-proof" class="section-header"><a href="#constructing-a-proof">Constructing a proof</a></h2>
<p>The prover prepares the input and output scalar lists, as well as the generators (which are needed to make commitments and to make the proof) and a transcript (which is needed to generate challenges). The <code>prove</code> function takes the list of scalar inputs and outputs, makes commitments to them, and creates a proof that the committed outputs are a valid reordering of the committed inputs. </p>
<p>For simplicity, in this example the <code>prove</code> function does not take a list of blinding factors for the inputs and outputs, so it is not possible to make a proof for existing committed points. However, it is possible to modify the function to take in a list of blinding factors instead of generating them internally. Also, in this example the <code>prove</code> function does not return the list of blinding factors generated, so it is not possible for the prover to open the commitments in the future. This can also be easily modified.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
 
<span class="kw">impl</span> <span class="ident">ShuffleProof</span> {
    <span class="doccomment">/// Attempt to construct a proof that `output` is a permutation of `input`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Returns a tuple `(proof, input_commitments || output_commitments)`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">prove</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span><span class="op">&gt;</span>(
        <span class="ident">pc_gens</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">PedersenGens</span>,
        <span class="ident">bp_gens</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">BulletproofGens</span>,
        <span class="ident">transcript</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">Transcript</span>,
        <span class="ident">input</span>: <span class="kw-2">&amp;</span>[<span class="ident">Scalar</span>],
        <span class="ident">output</span>: <span class="kw-2">&amp;</span>[<span class="ident">Scalar</span>],
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(<span class="ident">ShuffleProof</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">CompressedRistretto</span><span class="op">&gt;</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">CompressedRistretto</span><span class="op">&gt;</span>), <span class="ident">R1CSError</span><span class="op">&gt;</span> {
        <span class="comment">// Apply a domain separator with the shuffle parameters to the transcript</span>
        <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">len</span>();
        <span class="ident">transcript</span>.<span class="ident">commit_bytes</span>(<span class="string">b&quot;dom-sep&quot;</span>, <span class="string">b&quot;ShuffleProof&quot;</span>);
        <span class="ident">transcript</span>.<span class="ident">commit_bytes</span>(<span class="string">b&quot;k&quot;</span>, <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="ident">k</span> <span class="kw">as</span> <span class="ident">u64</span>).<span class="ident">as_bytes</span>());

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">prover</span> <span class="op">=</span> <span class="ident">Prover</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">pc_gens</span>, <span class="ident">transcript</span>);

        <span class="comment">// Construct blinding factors using an RNG.</span>
        <span class="comment">// Note: a non-example implementation would want to operate on existing commitments.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">blinding_rng</span> <span class="op">=</span> <span class="ident">rand</span>::<span class="ident">thread_rng</span>();

        <span class="kw">let</span> (<span class="ident">input_commitments</span>, <span class="ident">input_vars</span>): (<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span>) <span class="op">=</span> <span class="ident">input</span>.<span class="ident">into_iter</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> {
                <span class="ident">prover</span>.<span class="ident">commit</span>(<span class="kw-2">*</span><span class="ident">v</span>, <span class="ident">Scalar</span>::<span class="ident">random</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">blinding_rng</span>))
            })
            .<span class="ident">unzip</span>();

        <span class="kw">let</span> (<span class="ident">output_commitments</span>, <span class="ident">output_vars</span>): (<span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span>) <span class="op">=</span> <span class="ident">output</span>.<span class="ident">into_iter</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> {
                <span class="ident">prover</span>.<span class="ident">commit</span>(<span class="kw-2">*</span><span class="ident">v</span>, <span class="ident">Scalar</span>::<span class="ident">random</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">blinding_rng</span>))
            })
            .<span class="ident">unzip</span>();

        <span class="ident">ShuffleProof</span>::<span class="ident">gadget</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">prover</span>, <span class="ident">input_vars</span>, <span class="ident">output_vars</span>)<span class="question-mark">?</span>;

        <span class="kw">let</span> <span class="ident">proof</span> <span class="op">=</span> <span class="ident">prover</span>.<span class="ident">prove</span>(<span class="kw-2">&amp;</span><span class="ident">bp_gens</span>)<span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>((<span class="ident">ShuffleProof</span>(<span class="ident">proof</span>), <span class="ident">input_commitments</span>, <span class="ident">output_commitments</span>))
    }
}</pre></div>
<h2 id="verifiying-a-proof" class="section-header"><a href="#verifiying-a-proof">Verifiying a proof</a></h2>
<p>The verifier receives a proof, and a list of committed inputs and outputs, from the prover. It passes these to the <code>verify</code> function, which verifies that, given a shuffle proof and a list of committed inputs and outputs, the outputs are a valid reordering of the inputs. The verifier receives a <code>Result::ok()</code> if the proof verified correctly and a <code>Result::error(R1CSError)</code> otherwise.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="kw">impl</span> <span class="ident">ShuffleProof</span> {
    <span class="doccomment">/// Attempt to verify a `ShuffleProof`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">verify</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span><span class="op">&gt;</span>(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="ident">pc_gens</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">PedersenGens</span>,
        <span class="ident">bp_gens</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">BulletproofGens</span>,
        <span class="ident">transcript</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">Transcript</span>,
        <span class="ident">input_commitments</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">CompressedRistretto</span><span class="op">&gt;</span>,
        <span class="ident">output_commitments</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">CompressedRistretto</span><span class="op">&gt;</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">R1CSError</span><span class="op">&gt;</span> {
        <span class="comment">// Apply a domain separator with the shuffle parameters to the transcript</span>
        <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="ident">input_commitments</span>.<span class="ident">len</span>();
        <span class="ident">transcript</span>.<span class="ident">commit_bytes</span>(<span class="string">b&quot;dom-sep&quot;</span>, <span class="string">b&quot;ShuffleProof&quot;</span>);
        <span class="ident">transcript</span>.<span class="ident">commit_bytes</span>(<span class="string">b&quot;k&quot;</span>, <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="ident">k</span> <span class="kw">as</span> <span class="ident">u64</span>).<span class="ident">as_bytes</span>());

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">verifier</span> <span class="op">=</span> <span class="ident">Verifier</span>::<span class="ident">new</span>(<span class="ident">transcript</span>);

        <span class="kw">let</span> <span class="ident">input_vars</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">input_commitments</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">commitment</span><span class="op">|</span> {
            <span class="ident">verifier</span>.<span class="ident">commit</span>(<span class="kw-2">*</span><span class="ident">commitment</span>)
        }).<span class="ident">collect</span>();

        <span class="kw">let</span> <span class="ident">output_vars</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">output_commitments</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">commitment</span><span class="op">|</span> {
            <span class="ident">verifier</span>.<span class="ident">commit</span>(<span class="kw-2">*</span><span class="ident">commitment</span>)
        }).<span class="ident">collect</span>();

        <span class="ident">ShuffleProof</span>::<span class="ident">gadget</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">verifier</span>, <span class="ident">input_vars</span>, <span class="ident">output_vars</span>)<span class="question-mark">?</span>;

        <span class="ident">verifier</span>.<span class="ident">verify</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0</span>, <span class="kw-2">&amp;</span><span class="ident">pc_gens</span>, <span class="kw-2">&amp;</span><span class="ident">bp_gens</span>)
    }
}</pre></div>
<h2 id="using-the-shuffleproof" class="section-header"><a href="#using-the-shuffleproof">Using the <code>ShuffleProof</code></a></h2>
<p>Here, we use the <code>ShuffleProof</code> gadget by first constructing the common inputs to the <code>prove</code> and <code>verify</code> functions: the Pedersen and Bulletproofs generators. Next, the prover makes the other inputs to the <code>prove</code> function: the list of scalar inputs, the list of scalar outputs, and the prover transcript. The prover calls the <code>prove</code> function, and gets a proof and a list of committed points that represent the commitments to the input and output scalars.</p>
<p>The prover passes the proof and the commitments to the verifier. The verifier then makes the other inputs to the <code>verify</code> function: the verifier transcript. Note that the starting transcript state provides domain seperation between different applications, and must be the same for the prover and verifer transcript; if they are not, then the prover and verifier will receive different challenge scalars and the proof will not verify correctly. The verifier then calls the <code>verify</code> function, and gets back a <code>Result</code> representing whether or not the proof verified correctly.</p>
<p>Because only the prover knows the scalar values of the inputs and outputs, and the verifier only sees the committed inputs and outputs and not the scalar values themselves, the verifier has no knowledge of what the underlying inputs and outputs are. Therefore, the only information the verifier learns from this protocol is whether or not the committed outputs are a valid shuffle of the committed inputs - this is why it is a zero-knowledge proof.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="comment">// Construct generators. 1024 Bulletproofs generators is enough for 512-size shuffles.</span>
<span class="kw">let</span> <span class="ident">pc_gens</span> <span class="op">=</span> <span class="ident">PedersenGens</span>::<span class="ident">default</span>();
<span class="kw">let</span> <span class="ident">bp_gens</span> <span class="op">=</span> <span class="ident">BulletproofGens</span>::<span class="ident">new</span>(<span class="number">1024</span>, <span class="number">1</span>);

<span class="comment">// Putting the prover code in its own scope means we can&#39;t</span>
<span class="comment">// accidentally reuse prover data in the test.</span>
<span class="kw">let</span> (<span class="ident">proof</span>, <span class="ident">in_commitments</span>, <span class="ident">out_commitments</span>) <span class="op">=</span> {
    <span class="kw">let</span> <span class="ident">inputs</span> <span class="op">=</span> [
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">0u64</span>),
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">1u64</span>),
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">2u64</span>),
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">3u64</span>),
    ];
    <span class="kw">let</span> <span class="ident">outputs</span> <span class="op">=</span> [
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">2u64</span>),
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">3u64</span>),
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">0u64</span>),
        <span class="ident">Scalar</span>::<span class="ident">from</span>(<span class="number">1u64</span>),
    ];

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">prover_transcript</span> <span class="op">=</span> <span class="ident">Transcript</span>::<span class="ident">new</span>(<span class="string">b&quot;ShuffleProofTest&quot;</span>);
    <span class="ident">ShuffleProof</span>::<span class="ident">prove</span>(
        <span class="kw-2">&amp;</span><span class="ident">pc_gens</span>,
        <span class="kw-2">&amp;</span><span class="ident">bp_gens</span>,
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">prover_transcript</span>,
        <span class="kw-2">&amp;</span><span class="ident">inputs</span>,
        <span class="kw-2">&amp;</span><span class="ident">outputs</span>,
    )
    .<span class="ident">expect</span>(<span class="string">&quot;error during proving&quot;</span>)
};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">verifier_transcript</span> <span class="op">=</span> <span class="ident">Transcript</span>::<span class="ident">new</span>(<span class="string">b&quot;ShuffleProofTest&quot;</span>);
<span class="macro">assert</span><span class="macro">!</span>(
    <span class="ident">proof</span>
        .<span class="ident">verify</span>(<span class="kw-2">&amp;</span><span class="ident">pc_gens</span>, <span class="kw-2">&amp;</span><span class="ident">bp_gens</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">verifier_transcript</span>, <span class="kw-2">&amp;</span><span class="ident">in_commitments</span>, <span class="kw-2">&amp;</span><span class="ident">out_commitments</span>)
        .<span class="ident">is_ok</span>()
);</pre></div>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.LinearCombination.html" title='bulletproofs::r1cs::LinearCombination struct'>LinearCombination</a></td><td class='docblock-short'><p>Represents a linear combination of
<a href="../../bulletproofs/r1cs/enum.Variable.html"><code>Variables</code></a>.  Each term is represented by a
<code>(Variable, Scalar)</code> pair.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Prover.html" title='bulletproofs::r1cs::Prover struct'>Prover</a></td><td class='docblock-short'><p>A <a href="../../bulletproofs/r1cs/trait.ConstraintSystem.html" title="`ConstraintSystem`"><code>ConstraintSystem</code></a> implementation for use by the prover.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.R1CSProof.html" title='bulletproofs::r1cs::R1CSProof struct'>R1CSProof</a></td><td class='docblock-short'><p>A proof of some statement specified by a
<a href="../../bulletproofs/r1cs/trait.ConstraintSystem.html"><code>ConstraintSystem</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Verifier.html" title='bulletproofs::r1cs::Verifier struct'>Verifier</a></td><td class='docblock-short'><p>A <a href="../../bulletproofs/r1cs/trait.ConstraintSystem.html" title="`ConstraintSystem`"><code>ConstraintSystem</code></a> implementation for use by the verifier.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.R1CSError.html" title='bulletproofs::r1cs::R1CSError enum'>R1CSError</a></td><td class='docblock-short'><p>Represents an error during the proving or verifying of a constraint system.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Variable.html" title='bulletproofs::r1cs::Variable enum'>Variable</a></td><td class='docblock-short'><p>Represents a variable in a constraint system.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.ConstraintSystem.html" title='bulletproofs::r1cs::ConstraintSystem trait'>ConstraintSystem</a></td><td class='docblock-short'><p>The interface for a constraint system, abstracting over the prover
and verifier's roles.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.RandomizableConstraintSystem.html" title='bulletproofs::r1cs::RandomizableConstraintSystem trait'>RandomizableConstraintSystem</a></td><td class='docblock-short'><p>An extension to the constraint system trait that permits randomized constraints.
Gadgets that do not use randomization should use trait bound <code>CS: ConstraintSystem</code>,
while gadgets that need randomization should use trait bound <code>CS: RandomizedConstraintSystem</code>.
Gadgets generally <em>should not</em> use this trait as a bound on the CS argument: it should be used
by the higher-order protocol that composes gadgets together.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.RandomizedConstraintSystem.html" title='bulletproofs::r1cs::RandomizedConstraintSystem trait'>RandomizedConstraintSystem</a></td><td class='docblock-short'><p>Represents a constraint system in the second phase:
when the challenges can be sampled to create randomized constraints.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "bulletproofs";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>